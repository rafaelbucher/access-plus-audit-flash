"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QualwebPage = void 0;
const axios_1 = __importDefault(require("axios"));
const constants_1 = require("./constants");
class QualwebPage {
    pluginManager;
    page;
    url;
    html;
    constructor(pluginManager, page, url, html) {
        if (!url && !html) {
            throw new Error('Neither a url nor html content was provided.');
        }
        this.pluginManager = pluginManager;
        this.page = page;
        this.url = url;
        this.html = html;
    }
    getInputUrl() {
        return this.url;
    }
    getFinalUrl() {
        return this.page.url();
    }
    getTitle() {
        return this.page.title();
    }
    async getNumberOfHTMLElements() {
        return (await this.page.$$('*')).length;
    }
    getOuterHTML() {
        return this.page.evaluate(() => document.documentElement.outerHTML);
    }
    getUserAgent() {
        return this.page.browser().userAgent();
    }
    async getTestingData(options) {
        await this.page.setBypassCSP(true);
        await this.setViewport(options.viewport);
        await this.pluginManager.executeBeforePageLoad(this.page, this.url);
        const testingData = {};
        if (this.url) {
            const [response, validation, sourceHtml] = await Promise.all([
                this.navigateToPage(options),
                this.getValidatorResult(options.validator),
                this.getSourceHtml(options.viewport)
            ]);
            testingData.validation = validation;
            testingData.sourceHtml = sourceHtml;
            const sourceHTMLPuppeteer = await response?.text();
            if (!this.isHtmlDocument(sourceHTMLPuppeteer)) {
                await this.page.goBack();
                await this.page.setContent('<!DOCTYPE html><html nonHTMLPage=true><body></body></html>', {
                    timeout: options.timeout
                });
            }
        }
        else if (this.html) {
            await this.page.setContent(this.html, {
                timeout: options.timeout ?? 60 * 1000,
                waitUntil: options.waitUntil ?? 'load'
            });
            testingData.sourceHtml = await this.page.content();
        }
        testingData.newTabWasOpen = await this.extraTabOpened();
        await this.pluginManager.executeAfterPageLoad(this.page);
        this.addNecessaryScripts();
        return testingData;
    }
    async addNecessaryScripts() {
        await this.page.addScriptTag({
            path: require.resolve('@qualweb/qw-page'),
            type: 'text/javascript'
        });
        await this.page.addScriptTag({
            path: require.resolve('@qualweb/util'),
            type: 'text/javascript'
        });
        await this.page.addScriptTag({
            path: require.resolve('@qualweb/locale'),
            type: 'text/javascript'
        });
    }
    async addEvaluationScript(module) {
        await this.page.addScriptTag({
            path: require.resolve(module),
            type: 'text/javascript'
        });
    }
    evaluate(pageFunction, ...args) {
        return this.page.evaluate(pageFunction, ...args);
    }
    async navigateToPage(options) {
        this.page.on('dialog', (dialog) => dialog.dismiss());
        return this.page.goto(this.url ?? '', {
            timeout: options.timeout ?? 240 * 1000,
            waitUntil: options.waitUntil ?? 'load'
        });
    }
    getViewport() {
        return this.page.viewport();
    }
    async setViewport(options) {
        if (options) {
            if (options.userAgent) {
                await this.page.setUserAgent(options.userAgent);
            }
            else if (options.mobile) {
                await this.page.setUserAgent(constants_1.DEFAULT_MOBILE_USER_AGENT);
            }
            else {
                await this.page.setUserAgent(constants_1.DEFAULT_DESKTOP_USER_AGENT);
            }
            await this.page.setViewport(this.createViewportObject(options));
        }
        else {
            await this.page.setViewport({
                width: constants_1.DEFAULT_DESKTOP_PAGE_VIEWPORT_WIDTH,
                height: constants_1.DEFAULT_DESKTOP_PAGE_VIEWPORT_HEIGHT,
                isMobile: false,
                hasTouch: false,
                isLandscape: true
            });
        }
    }
    createViewportObject(options) {
        const viewport = {
            width: options.mobile ? constants_1.DEFAULT_MOBILE_PAGE_VIEWPORT_WIDTH : constants_1.DEFAULT_DESKTOP_PAGE_VIEWPORT_WIDTH,
            height: options.mobile ? constants_1.DEFAULT_MOBILE_PAGE_VIEWPORT_HEIGHT : constants_1.DEFAULT_DESKTOP_PAGE_VIEWPORT_HEIGHT
        };
        if (options.resolution?.width) {
            viewport.width = options.resolution.width;
        }
        if (options.resolution?.height) {
            viewport.height = options.resolution.height;
        }
        viewport.isMobile = !!options.mobile;
        viewport.isLandscape = options.landscape ?? viewport.width > viewport.height;
        viewport.hasTouch = !!options.mobile;
        return viewport;
    }
    async extraTabOpened() {
        const tabs = await this.page.browser().pages();
        let extraTabOpened = false;
        for (const tab of tabs ?? []) {
            const target = tab.target();
            const opener = target.opener();
            if (opener) {
                const openerPage = await opener.page();
                if (openerPage && openerPage.url() === this.page.url()) {
                    extraTabOpened = true;
                    await tab.close();
                }
            }
        }
        return extraTabOpened;
    }
    async getSourceHtml(options) {
        try {
            const fetchOptions = {
                headers: {
                    'User-Agent': options
                        ? options.userAgent
                            ? options.userAgent
                            : options.mobile
                                ? constants_1.DEFAULT_MOBILE_USER_AGENT
                                : constants_1.DEFAULT_DESKTOP_USER_AGENT
                        : constants_1.DEFAULT_DESKTOP_USER_AGENT
                }
            };
            const response = await axios_1.default.get(this.url ?? '', fetchOptions);
            return response.data.trim();
        }
        catch (e) {
            return '';
        }
    }
    async getValidatorResult(endpoint) {
        if (endpoint) {
            const validationUrl = endpoint + encodeURIComponent(this.url ?? '');
            try {
                const response = await axios_1.default.get(validationUrl, { timeout: 10 * 1000 });
                if (response && response.status === 200) {
                    return response.data;
                }
            }
            catch (e) {
                console.error('Error fetching HTML Validation: ' + e);
            }
        }
        return undefined;
    }
    isHtmlDocument(content) {
        if (this.url && (this.url.endsWith('.svg') || this.url.endsWith('.xml') || this.url.endsWith('.xhtml'))) {
            return false;
        }
        return !((content?.trim().startsWith('<math') || content?.trim().startsWith('<svg')) &&
            !content?.includes('<html'));
    }
}
exports.QualwebPage = QualwebPage;
//# sourceMappingURL=QualwebPage.object.js.map