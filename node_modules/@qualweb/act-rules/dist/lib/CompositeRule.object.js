"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompositeRule = void 0;
const evaluation_1 = require("@qualweb/core/evaluation");
const Rule_object_1 = require("./Rule.object");
class CompositeRule extends Rule_object_1.Rule {
    conjunction(element, rules) {
        const test = new evaluation_1.Test();
        const selector = element.getElementSelector();
        const results = this.getAtomicRuleResultPerVerdict(selector, rules);
        const translation = this.translate(test.resultCode);
        if (results['failed']) {
            test.verdict = evaluation_1.Verdict.FAILED;
            test.resultCode = 'F1';
            test.description = translation + results['failed'].code;
        }
        else if (results['warning']) {
            test.verdict = evaluation_1.Verdict.WARNING;
            test.resultCode = 'W1';
            test.description = translation + results['warning'].code;
        }
        else if (results['passed']) {
            test.verdict = evaluation_1.Verdict.PASSED;
            test.resultCode = 'P1';
            test.description = translation + results['passed'].code;
        }
        test.addElement(element);
        super.addTestResult(test);
    }
    disjunction(element, rules) {
        const test = new evaluation_1.Test();
        const selector = element.getElementSelector();
        const results = this.getAtomicRuleResultPerVerdict(selector, rules);
        const translation = this.translate(test.resultCode);
        if (results['passed']) {
            test.verdict = evaluation_1.Verdict.PASSED;
            test.resultCode = 'P1';
            test.description = translation + results['passed'].code;
        }
        else if (results['warning']) {
            test.verdict = evaluation_1.Verdict.WARNING;
            test.resultCode = 'W1';
            test.description = translation + results['warning'].code;
        }
        else if (results['failed']) {
            test.verdict = evaluation_1.Verdict.FAILED;
            test.resultCode = 'F1';
            test.description = translation + results['failed'].code;
        }
        test.addElement(element);
        super.addTestResult(test);
    }
    getAtomicRuleResultPerVerdict(selector, rules) {
        const ruleResult = {};
        for (const rule of rules !== null && rules !== void 0 ? rules : []) {
            if (rule) {
                for (const result of rule.results) {
                    if (result.elements && result.elements[0].pointer === selector && !ruleResult[result.verdict]) {
                        ruleResult[result.verdict] = { title: rule.name, code: rule.code };
                    }
                }
            }
        }
        return ruleResult;
    }
    getAtomicRuleResultForElement(selector, rules) {
        var _a;
        const ruleResult = {};
        for (const rule of rules !== null && rules !== void 0 ? rules : []) {
            ruleResult[rule.code] = { title: rule.name, code: rule.code, verdict: evaluation_1.Verdict.INAPPLICABLE };
            for (const result of (_a = rule.results) !== null && _a !== void 0 ? _a : []) {
                if (result.elements && result.elements[0].pointer === selector) {
                    ruleResult[rule.code] = { title: rule.name, code: rule.code, verdict: result.verdict };
                }
            }
        }
        return ruleResult;
    }
}
exports.CompositeRule = CompositeRule;
