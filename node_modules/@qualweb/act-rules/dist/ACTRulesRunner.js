"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ACTRulesRunner = void 0;
const locale_1 = require("@qualweb/core/locale");
const evaluation_1 = require("@qualweb/core/evaluation");
const ACTRulesTester_object_1 = require("./lib/ACTRulesTester.object");
class ACTRulesRunner extends evaluation_1.EvaluationModuleDefinition {
    constructor(moduleOptions, translationOptions) {
        const moduleType = evaluation_1.ModuleType.ACT_RULES;
        const report = new evaluation_1.ModuleReport(moduleType);
        const tester = new ACTRulesTester_object_1.ACTRulesTester(report);
        super(moduleType, moduleOptions, translationOptions, report, tester);
        this.translator = new locale_1.ModuleTranslator(this.type, this.translate);
        this.tester.init(this.translator);
    }
    configure(options) {
        super.configure(options || this.moduleOptions);
        this.tester.configureCompositeRules();
        return this;
    }
    test(data) {
        const metaElements = this.getMetaElements(data.sourceHtml);
        this.tester.validateMetaElements(metaElements);
        this.tester.execute();
        return this;
    }
    getMetaElements(sourceHtml) {
        if (!sourceHtml) {
            return [];
        }
        const parser = new DOMParser();
        const sourceDoc = parser.parseFromString('', 'text/html');
        sourceDoc.documentElement.innerHTML = sourceHtml;
        const elements = sourceDoc.querySelectorAll('meta');
        const metaElements = new Array();
        elements.forEach((element) => metaElements.push(window.qwPage.createQWElement(element)));
        return metaElements;
    }
    testSpecial() {
        this.tester.validateZoomedTextNodeNotClippedWithCSSOverflow();
        return this;
    }
}
exports.ACTRulesRunner = ACTRulesRunner;
