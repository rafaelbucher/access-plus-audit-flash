"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QW_ACT_R7 = void 0;
const applicability_1 = require("@qualweb/util/applicability");
const evaluation_1 = require("@qualweb/core/evaluation");
const AtomicRule_object_1 = require("../lib/AtomicRule.object");
class QW_ACT_R7 extends AtomicRule_object_1.AtomicRule {
    execute(element) {
        const rules = element.getCSSRules();
        let transformValue = null;
        for (const property in rules || {}) {
            if (rules && rules[property]) {
                if (property === 'transform') {
                    const value = rules[property].value;
                    if (value.startsWith('rotate') || value.startsWith('rotate3d') || value.startsWith('rotateZ')) {
                        const angle = value.replace(value.split('(')[0], '').replace('(', '').replace(')', '');
                        transformValue = this.parseDegrees(angle);
                    }
                }
                else if (property === 'rotate') {
                    const value = rules[property].value;
                    transformValue = this.parseDegrees(value);
                }
            }
        }
        const media = rules === null || rules === void 0 ? void 0 : rules.media;
        if (media) {
            for (const condition in media) {
                if (condition.includes('orientation:') && (condition.includes('portrait') || condition.includes('landscape'))) {
                    for (const property in media[condition] || {}) {
                        if (property === 'transform') {
                            const cssProperty = media[condition][property];
                            const value = cssProperty.value;
                            if (value.startsWith('rotate') || value.startsWith('rotate3d') || value.startsWith('rotateZ')) {
                                let angle = value.replace(value.split('(')[0], '').replace('(', '').replace(')', '');
                                angle = this.parseDegrees(angle.toString()).toString();
                                const matrix = this.rotateZ(transformValue ? parseFloat(angle) - transformValue : parseFloat(angle));
                                angle = this.calculateRotationDegree(matrix).toString();
                                this.checkRotation(element, parseInt(angle));
                            }
                            else if (value.startsWith('matrix(') || value.startsWith('matrix3d(')) {
                                const matrix = this.fromString(value);
                                this.calculateRotationDegree(matrix);
                                const angle = this.calculateRotationDegree(matrix);
                                this.checkRotation(element, angle);
                            }
                        }
                        else if (property === 'rotate') {
                            const cssProperty = media[condition][property];
                            const value = cssProperty.value;
                            const angle = this.parseDegrees(value.toString());
                            this.checkRotation(element, angle);
                        }
                    }
                }
            }
        }
    }
    checkRotation(element, angle) {
        const test = new evaluation_1.Test();
        if (angle === 90 || angle === 270) {
            test.verdict = evaluation_1.Verdict.FAILED;
            test.resultCode = 'F1';
        }
        else {
            test.verdict = evaluation_1.Verdict.PASSED;
            test.resultCode = 'P1';
        }
        test.addElement(element);
        this.addTestResult(test);
    }
    parseDegrees(angle) {
        angle = angle.toLowerCase();
        if (angle.includes('deg')) {
            return parseFloat(angle.replace('deg', ''));
        }
        else if (angle.includes('rad')) {
            const radians = parseFloat(angle.replace('rad', ''));
            return (radians * 180) / Math.PI;
        }
        else if (angle.includes('turn')) {
            const turnDegrees = 360;
            const turns = parseFloat(angle.replace('turn', ''));
            return turns * turnDegrees;
        }
        else {
            return -1;
        }
    }
    calculateRotationDegree(matrix) {
        const radians = Math.atan2(matrix[1], matrix[0]);
        let degrees = Math.round((radians * 180) / Math.PI);
        if (degrees < 0) {
            degrees = 360 + degrees;
        }
        return Math.abs(degrees);
    }
    identity() {
        const matrix = new Array();
        for (let i = 0; i < 16; i++) {
            i % 5 === 0 ? matrix.push(1) : matrix.push(0);
        }
        return matrix;
    }
    rotateZ(angle) {
        const theta = (Math.PI / 180) * angle;
        const matrix = this.identity();
        matrix[0] = matrix[5] = Math.cos(theta);
        matrix[1] = matrix[4] = Math.sin(theta);
        matrix[4] *= -1;
        return matrix;
    }
    fromString(source) {
        if (typeof source === 'string') {
            const match = source.match(/matrix(3d)?\(([^)]+)\)/);
            if (match) {
                const raw = match[2].split(',').map(parseFloat);
                return this.format(raw);
            }
            if (source === 'none' || source === '') {
                return this.identity();
            }
        }
        throw new TypeError('Expected a string containing `matrix()` or `matrix3d()');
    }
    format(source) {
        const values = source
            .filter(function (value) {
            return typeof value === 'number';
        })
            .filter(function (value) {
            return !isNaN(value);
        });
        if (source.length === 6 && values.length === 6) {
            const matrix = this.identity();
            matrix[0] = values[0];
            matrix[1] = values[1];
            matrix[4] = values[2];
            matrix[5] = values[3];
            matrix[12] = values[4];
            matrix[13] = values[5];
            return matrix;
        }
        else if (source.length === 16 && values.length === 16) {
            return source;
        }
        throw new TypeError('Expected a `number[]` with length 6 or 16.');
    }
}
exports.QW_ACT_R7 = QW_ACT_R7;
__decorate([
    applicability_1.ElementExists,
    applicability_1.ElementIsVisible,
    applicability_1.ElementHasCSSRules,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", void 0)
], QW_ACT_R7.prototype, "execute", null);
